#RabbitJump

##Основные источники*
1. [RabbitMQ Tutorial](https://www.rabbitmq.com/getstarted.html)
1. [php-amqplib](https://github.com/php-amqplib/php-amqplib)
1. [Reliable messaging with RabbitMQ (video)](https://www.youtube.com/watch?v=XjuiZM7JzPw)

\* - основные.

##Установка
1. php 7.1+
2. RabbitMQ 3.7+ (AMQP 0.9+)

Следуем инструкциям `https://www.rabbitmq.com/download.html` для своей системы.
Не забываем установить ulimit (если это Linux и есть такая необходимость).
Порт RabbitMQ по умолчанию `5672`, порт UI-консоли `15672`.

###Ниже краткая инструкция для Debian / Ubuntu:

Устанавливаем из репозитория:

`sudo aptitude install rabbitmq-server`

Включаем RabbitMQ UI:

`sudo rabbitmq-plugins enable rabbitmq_management`

Заходим на `http://localhost:15672/`

В свежей установке логин/пароль: `guest:guest`

Проверяем количество доступных дескрипторов файлов.

Если есть необходимость, конфигурируем `ulimit` системный и для пользователя `rabbitmq`.

###Дополнительно
Для использования RabbitMQ в своём проекте необходимо подключить какой-нибудь пакет для общения по протоколу `AMQP`.
Например, `php-amqplib/php-amqplib` (`composer require php-amqplib/php-amqplib`).

#Задание 1. Простейшее однократное взаимодействие.
Знакомимся с RabbitMQ.

1. Подключиться к RabbitMQ
1. Отправить одно сообщение в очередь 'hello'
1. Принять одно сообщение из очереди 'hello'

Для реализации [потребуется](docs/e1.md):

1. Открыть соединение с RabbitMQ, используя параметры host, port, user, password.
1. Открыть канал подключения. 
1. Подключиться к очереди 'hello' в RabbitMQ (при отсутствии создать её).
1. Отправить сообщение в очередь.
1. Закрыть канал и соединение.
1. Открыть соединение с RabbitMQ, используя параметры host, port, user, password.
1. Открыть канал подключения. 
1. Подключиться к очереди 'hello' в RabbitMQ (при отсутствии создать её).
1. Прочитать одно сообщение из очереди.
1. Отправить подтверждение о том, что сообщение прочитано.
1. Закрыть канал и соединение.

В примере для общения с RabbitMQ используется `AMQPStreamConnection`. При однократной отправке и получении сообщений в потоке нет необходимости.

Для запуска примера:
1. `cd cli`
1. `php index.php -c producer`
1. `php index.php -c consumer`

При желании можно воспользоваться командой `php index.php -c producer -p "m=MESSAGE"` для отправки своего сообщения.

См. классы `ConsumerCommand`, `ProducerCommand`. 


#Задание 2. Потоки сообщений.
Знакомимся с возможностями обработки сообщений и буферизации.

1. Подключиться к RabbitMQ
1. Запустить поток сообщений в очередь 'hello'
1. Запустить поток приёма сообщений из очереди 'hello'

Для реализации [потребуется](docs/e2.md):

1. Открыть соединение с RabbitMQ, используя параметры host, port, user, password.
1. Открыть канал подключения. 
1. Подключиться к очереди 'hello' в RabbitMQ (при отсутствии создать её).
1. Отправлять сообщения в очередь в цикле.
1. Открыть соединение с RabbitMQ, используя параметры host, port, user, password.
1. Открыть канал подключения. 
1. Подключиться к очереди 'hello' в RabbitMQ (при отсутствии создать её).
1. Начать цикл получения сообщений из очереди.

В примере для общения с RabbitMQ используется `AMQPStreamConnection`.

Для запуска примера:
1. `cd cli`
1. В одной консоли: `php index.php -c generating_producer`
1. В другой консоли: `php index.php -c waiting_consumer`

При желании можно воспользоваться параметрами:

 `php index.php -c generating_producer -p "m=MESSAGE" -p delay=2` 
 для отправки своего сообщения и установки времени задержки между сообщениями (по умолчанию 1 секунда).

 `php index.php -c waiting_consumer -p delay=2` 
 для отправки своего сообщения и установки времени задержки между приёмом сообщений (по умолчанию нет).

См. классы `WaitingConsumerCommand`, `GeneratingProducerCommand`. 


#Задание 3. Эмуляция СМО с задержкой при обработке сообщений.
Эмулируем систему с несколькими генераторами сообщений, несколькими обработчиками и разной скоростью обработки сообщений.

1. Подключиться к RabbitMQ
1. Запустить несколько потоков сообщений в очередь 'hello'
1. Запустить потоков приёма сообщений из очереди 'hello'

Для реализации потребуется (см. Задания 1, 2):

1. Открыть соединение с RabbitMQ, используя параметры host, port, user, password.
1. Открыть канал подключения. 
1. Подключиться к очереди 'hello' в RabbitMQ (при отсутствии создать её).
1. Отправлять сообщения в очередь в цикле.
1. Открыть соединение с RabbitMQ, используя параметры host, port, user, password.
1. Открыть канал подключения. 
1. Подключиться к очереди 'hello' в RabbitMQ (при отсутствии создать её).
1. Начать цикл получения сообщений из очереди.
1. Повторить пп. 1-8 несколько раз. 

В примере для общения с RabbitMQ используется `AMQPStreamConnection`.

Для запуска примера:
1. `cd cli`
1. В нескольких консолях: `php index.php -c generating_producer -p rd=true`
1. В нескольких консолях: `php index.php -c waiting_consumer`

Пронаблюдать за логами. Установить равновесие между генераторами и обработчиками.
Обратить внимание на web-консоль: в ней сообщения не накапливаются в очереди.

См. классы `WaitingConsumerCommand`, `GeneratingProducerCommand`. 

#Задание 4. Подверждение о получении.

До этого момента мы имели део со случаем, когда подтверждение о получении сообщения приходит сразу после получения его потребителем вне зависимости от скорости обработки сообщения.

Попробуем сделать подтверждение сообщений после обработки.

1. Подключиться к RabbitMQ
1. Запустить несколько потоков сообщений в очередь 'hello'
1. Запустить потоков приёма сообщений из очереди 'hello'

Для реализации потребуется (см. Задания 1, 2):

1. Открыть соединение с RabbitMQ, используя параметры host, port, user, password.
1. Открыть канал подключения. 
1. Подключиться к очереди 'hello' в RabbitMQ (при отсутствии создать её).
1. Отправлять сообщения в очередь в цикле.
1. Открыть соединение с RabbitMQ, используя параметры host, port, user, password.
1. Открыть канал подключения. 
1. Подключиться к очереди 'hello' в RabbitMQ (при отсутствии создать её).
1. Начать цикл получения сообщений из очереди с подтверждением после обработки.
1. Повторить пп. 1-8 несколько раз. 

В примере для общения с RabbitMQ используется `AMQPStreamConnection`.

Для запуска примера:
1. `cd cli`
1. В нескольких консолях: `php index.php -c generating_producer -p rd=true`
1. В нескольких консолях: `php index.php -c ack_consumer`

Пронаблюдать за логами. Установить равновесие между генераторами и обработчиками.
Обратить внимание на web-консоль: в ней накапливается некоторое количество неподтверждённых сообщений.

Накопить неподтвержённые сообщения. Закрыть генераторы. 
Закрыть один из потоков-обработчиков. 
Открыть новый, закрыть остальные. 
Убедиться, что в новый поток пришли сообщения, оставшиеся необработанными.

См. классы `AckConsumerCommand`, `GeneratingProducerCommand`. 

#Задание 5. Durable. Сообщения, хранящиеся на диске.

Одной из точек отказа является сам RabbitMQ. Для обеспечения сохранности принятых, но не обработанных сообщений, воспользуемся параметром `durable` при создании очереди.

Т.к. нельзя изменять параметры уже созданной очереди, создадим очередь с другим именем.

В остальном, см. Задания 3, 4.

Для запуска примера:
1. `cd cli`
1. В нескольких консолях: `php index.php -c durable_producer -p rd=true`
1. В нескольких консолях: `php index.php -c durable_consumer`

См. классы `DurableConsumerCommand`, `DurableProducerCommand`.

#Задание 6. Fair. Отложенная рассылка сообщений.

По умолчанию RabbitMQ равномерно распределяет по активным обработчикам сообщения сразу, как только они приходят.
Однако нагрузка при обработке сообщений может быть неравномерной. что приведёт к накоплению сообщений в буфере обработчика.
Используем метод, при котором следующее сообщение поступает обработчику только тогда, когда он подтверждает обработку предыдущего.

Обратите внимание, что при параллельном использовании обработчика без распределения нагрузки, ему будут приходить все сообщения, пришедшие в момент пока остальные заняты.

См. Задания 3, 4.

Для запуска примера:
1. `cd cli`
1. В нескольких консолях: `php index.php -c generating_producer -p rd=true`
1. В нескольких консолях: `php index.php -c fair_consumer`


См. класс `FairConsumerCommand`.

#Задание 7. Fanout. Рассылка собщений с помощью обменника.
Ранее мы работали с непосредственным обемном сообщений через очередь, имитируя обмен скорее тасками, чем сообщениями.
Опробуем работу с генератором сообщений, который ничего не знает об очередях потребителей и готов отправлять данные кому угодно.

Для реализации [потребуется](docs/e7.md):

1. Открыть соединение с RabbitMQ, используя параметры host, port, user, password.
1. Открыть канал подключения. 
1. Создать и/или подключть обменник для сообщений типа `fanout`.
1. Запустить отправку сообщений
1. Открыть соединение с RabbitMQ, используя параметры host, port, user, password.
1. Открыть канал подключения. 
1. Сгенерировать очередь и подключить её к обменнику.
1. Запустить чтение сообщений из очереди.
1. Повторить пп. 5-8.

Убедимся, что в панели управления появился наш обменник, несколько новых очередей, а так же в том, что все очереди получают все сообщения от обменника, а не по одному, как раньше.

Для запуска примера:
1. `cd cli`
1. В одной консоли: `php index.php -c fanout_producer -p`
1. В нескольких консолях: `php index.php -c fanout_consumer`

См. классы `FanoutConsumerCommand`, `FanoutProducerCommand`

#Задание 8. Маршрутизация сообщений.
`Fanout`-обменник отправляет сообщение всем подписанным на него очередям.
Сегрегируем очереди с помощью ключей маршрутизации и обменника `direct`.

Для реализации [потребуется](docs/e8.md):

1. Открыть соединение с RabbitMQ, используя параметры host, port, user, password.
1. Открыть канал подключения. 
1. Создать и/или подключть обменник для сообщений типа `direct`.
1. Отправлять сообщения по одному с указанием ключа маршрутизации.
1. Открыть соединение с RabbitMQ, используя параметры host, port, user, password.
1. Открыть канал подключения. 
1. Сгенерировать очередь и подключить её к обменнику с укзанием, сообщения с каким ключом она должна принимать.
1. Запустить чтение сообщений из очереди.
1. Повторить пп. 5-8.

Убедимся, что в панели управления появился наш обменник, несколько новых очередей, а так же в том, что очереди получают сообщения от обменника соответственно настроенным ключам.

Для запуска примера:
1. `cd cli`
1. В нескольких консолях: `php index.php -c direct_consumer -p rk=ключ` - с разными ключами.
1. В другой консоли запускать: `php index.php -c direct_producer -p rk=ключ` - с разными ключами.
1. Допускается подключать несколько очередей с одинаковым ключом.

См. классы `DirectConsumerCommand`, `DirectProducerCommand`